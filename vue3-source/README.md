## 3.0 跟 2.x 的区别
1. 源码区别
   1. 使用 typescript 全部重写
   2. 使用 Monorepo 组织项目结构 把独立的功能模块提取到不同的包中，更好的维护依赖关系。
   3. reactivity -> runtime-core -> runtime-dom
2. 代码虽然全部重写 但是 90% 以上的 API 仍然兼容 2.x
   1. 移除了不常用的 api 例如 inline-template filter等
   2. vue3采用函数式的写法，更好的支持 tree shaking 让打包后的体积更少，使得 transition 等一些组件变成按需引入
3. 增加了 composition API （组合式 API） 解决了 vue 2.x 中 使用超大组件使用 options api 不好拆分跟重用的问题
   1. 基于函数的API
   2. 可以更灵活的组织组件的逻辑
   3. options api 在开发大型组件时 需要上下拖动去找的对应的data method 声明周期等，要将相同功能的代码拆分到不同的地方。
   4. 在composition api 中只需要将所有的data method等这些相同功能写到一块封装成一个函数，做到更好的代码重用。
4. 性能方面有大幅度的提升
   1. 3.0 中使用 proxy 代理对象重写了响应式代码
      1. 2.x 中响应式的核心是 defineProperty 初始化时会遍历所有成员通过 defineProperty 将其转换成 get跟set。如果成员还是对象会递归处理，无论有没有使用该对象 都会进行响应式处理。无法监听动态增加的属性，删除的属性，数组的索引和length属性
      2. 3中采用proxy，该方法本身就比defineProperty性能好，另外代理对象可以拦截属性的访问赋值删除等操作，不需要初始化时遍历所有的属性。如果多层属性嵌套时只有访问某个属性时才会递归处理。使用proxy默认就可以监听属性的添加跟删除操作，还有数组的索引跟length。
   2. 对编译器做了优化重写了虚拟dom，使得渲染跟update的性能有了大幅度提升，服务端渲染的性能也提升了2-3倍
      1. 2.x中 通过标记静态根节点优化了 diff 过程，但是静态节点还需要进行diff，这个过程没有被优化。
      2. 3.0中标记和提升所有的静态节点，静态节点提升到render外层，只有在初始化时会创建静态节点，之后都会复用
      1. 模板中采用了Fragment，不再需要在组件中创建唯一根节点，可以创建跟部的同级节点了      
      2. 同过 blockTree + patch flag实现了靶向更新, 通过patchflag标记动态节点，blockTree收集动态节点，diff时只比对动态节点。
      3. 缓存事件函数，减少了不必要的更新操作。
5. 提供了 vite 开发工具，在开发阶段无需打包便可以直接运行项目 提升了开发效率
   1. 在 script 标签中添加 type="module" 来加载 es 模块
   2. 该方式加载的脚本会在 dom 树构建完毕 DOMContentLoaded 事件触发前执行
   3. vite 在开发模式下不需要打包直接运行 而 vue-cli 需要先打包整个项目才可运行
   4. vite 特定 快速冷启动 按需编译 模块热更新
   5. vite 在生产环境使用 rollup 基于es module方式进行打包 相比webpack打包体积更小
   6. 原理 使用浏览器支持的 es module 方式来加载模块，在开发环境下不会打包项目，把所有模块的请求都交给服务器来处理，在服务器来处理浏览器不能识别的模块，如果是单文件组件会调用compiler-sfc编译单文件组件，将编译后的结果返回给浏览器。